from typing import Dict, List, Optional
from datetime import datetime
import random

class NPC:
    def __init__(self, id: str, name: str, description: str, location: str, personality: Dict):
        self.id = id
        self.name = name
        self.description = description
        self.location = location
        self.personality = personality
        self.state = {
            "mood": "neutral",
            "trust_level": 0,
            "known_secrets": [],
            "current_goal": None
        }

    def update_state(self, interaction_result: Dict):
        """Update NPC state based on interaction results"""
        if "mood_change" in interaction_result:
            self.state["mood"] = interaction_result["mood_change"]
        if "trust_change" in interaction_result:
            self.state["trust_level"] += interaction_result["trust_change"]
        if "new_secret" in interaction_result:
            self.state["known_secrets"].append(interaction_result["new_secret"])
        if "new_goal" in interaction_result:
            self.state["current_goal"] = interaction_result["new_goal"]

    def get_state(self) -> Dict:
        """Get current NPC state"""
        return {
            "id": self.id,
            "name": self.name,
            "location": self.location,
            "state": self.state,
            "personality": self.personality
        }

class NPCManager:
    def __init__(self):
        self.npcs: Dict[str, NPC] = {}
        self._initialize_npcs()

    def _initialize_npcs(self):
        """Initialize the game's NPCs"""
        self.npcs = {
            "elder": NPC(
                id="elder",
                name="Elder Thalric",
                description="The village elder, wise but secretive",
                location="village_square",
                personality={
                    "traits": ["wise", "secretive", "protective"],
                    "goals": ["protect the village", "maintain order"],
                    "fears": ["chaos", "outsiders"],
                    "secrets": ["knows about the time loop"]
                }
            ),
            "blacksmith": NPC(
                id="blacksmith",
                name="Gorrik the Blacksmith",
                description="A burly blacksmith with a mysterious past",
                location="forge",
                personality={
                    "traits": ["strong", "mysterious", "loyal"],
                    "goals": ["protect his family", "keep his past hidden"],
                    "fears": ["his past being revealed"],
                    "secrets": ["was once a royal guard"]
                }
            ),
            "apothecary": NPC(
                id="apothecary",
                name="Mistress Althea",
                description="The village apothecary, knowledgeable about herbs and potions",
                location="apothecary_shop",
                personality={
                    "traits": ["knowledgeable", "curious", "helpful"],
                    "goals": ["find a cure", "help the villagers"],
                    "fears": ["the plague spreading"],
                    "secrets": ["has discovered a potential cure"]
                }
            )
        }

    def get_npc(self, npc_id: str) -> Optional[NPC]:
        """Get an NPC by ID"""
        return self.npcs.get(npc_id)

    def get_npcs_at_location(self, location: str) -> List[NPC]:
        """Get all NPCs at a specific location"""
        return [npc for npc in self.npcs.values() if npc.location == location]

    def update_npc_location(self, npc_id: str, new_location: str):
        """Update an NPC's location"""
        if npc := self.get_npc(npc_id):
            npc.location = new_location

    def process_interaction(self, npc_id: str, player_input: str, game_state: Dict) -> Dict:
        """Process an interaction with an NPC"""
        npc = self.get_npc(npc_id)
        if not npc:
            return {"error": "NPC not found"}

        # Generate interaction result based on NPC state and player input
        interaction_result = {
            "mood_change": random.choice(["positive", "negative", "neutral"]),
            "trust_change": random.randint(-1, 1),
            "new_secret": None,
            "new_goal": None
        }

        # Update NPC state
        npc.update_state(interaction_result)

        return {
            "npc_id": npc_id,
            "response": self._generate_response(npc, player_input, game_state),
            "state_changes": interaction_result
        }

    def _generate_response(self, npc: NPC, player_input: str, game_state: Dict) -> str:
        """Generate an NPC response based on their state and the interaction"""
        # This is a placeholder - the actual response will be generated by the AI
        base_responses = {
            "elder": [
                "The village's safety is my utmost concern.",
                "There are things you don't yet understand.",
                "The past holds many secrets."
            ],
            "blacksmith": [
                "I've seen many things in my time.",
                "My forge is my sanctuary.",
                "Some things are better left unsaid."
            ],
            "apothecary": [
                "The herbs speak to me in ways you wouldn't understand.",
                "I'm close to finding a solution.",
                "Every plant has its purpose."
            ]
        }

        # Select response based on NPC's mood and trust level
        mood_modifier = " (trustingly)" if npc.state["trust_level"] > 2 else " (suspiciously)"
        return random.choice(base_responses[npc.id]) + mood_modifier 